# 2019.9.20-
2019.9.20牛客网知识点补充

1.在委托事件模型中，源生成事件并把它发送给一个或多个监听器，每个监听器必须向事件源注册
2.垃圾回收是JVM自动进行的，可以调用System.GC()，提醒JVM执行垃圾回收，具体时间不确定；显示将局部变量或对象置空，可以达到标识某个局部变量不再被使用的目的，同时建议GC对该局部变量进行回收，但真正什么时候回收还是不确定的。
3.String s="welcome"+"to"+360:创建一个对象
4.“可见性”是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的；“原子性”是世界上最小的单位，具有不可分割性；关键字volatile是线程同步的轻量级实现，所以volatile性能肯定比synchronize要好，并且只能修改变量，而synchronize可以修饰方法，以及代码块；多线程访问volatile不会发生阻塞，而synchronize会出现阻塞；volatile能保证数据的可见性，但不能保证原子性；而synchronize可以保证原子性和可见性，因为它会将私有内存和公共内存中的数据同步；关键字volatile解决变量在多线程之间的可见性；synchronize解决多线程下的资源同步性。
5.基本类型的比较会将精度低的类型自动转化为高精度类型再比较。

6.当类的字节码文件加载到内存中时，类的实例方法并没有分配入口地址，只有当该类对象创建之后，实例方法才分配了入口地址；当类的字节码文件加载到内存中，类方法的入口地址就会分配完成，所以类方法不仅可以被该类调用，也可以直接通过类名完成调用。类方法的入口地址只有程序退出时才消失。实例方法不可以调用超类的私有实例方法
7.泛型顶多影响一下变异速度，由于泛型有擦除机制存在，不会影响运行时间，不能提升运行性能。
8.抽象类不能被实例化，无法用new关键字调用抽象类的构造器创建抽象类的实例额，即使抽象类不包含抽象方法，也不能被实例化。继承一个抽象父类，但是没有完全实现父类包含的抽象方法；实现一个接口，但是没有完全实现接口包含的抽象方法。
9.system.out.println(++i);打印表达式结果1
  system.out.println(i++);打印中间变量0
10.对volatile变量的操作不是原子性，但是是可见性；不会阻塞，三十多线程用synchronize。

11.

